<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JDK动态代理]]></title>
      <url>http://4rnold.github.io/2016/07/06/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>动态代理JDK和cglib都为我们提供了现成的解决方案</p>
<blockquote>
<p><strong>代理Proxy 和RealSubject 应该实现相同的功能，这一点相当重要。（我这里说的功能，可以理解为某个类的public方法）</strong></p>
<p>在面向对象的编程之中，如果我们想要约定Proxy 和RealSubject可以实现相同的功能，有两种方式：</p>
<blockquote>
<p>   a.一个比较直观的方式，就是定义一个功能接口，然后让Proxy 和RealSubject来实现这个接口。</p>
<p>   b.还有比较隐晦的方式，就是通过继承。因为如果Proxy 继承自RealSubject，这样Proxy则拥有了RealSubject的功能，Proxy还可以通过重写RealSubject中的方法，来实现多态。</p>
</blockquote>
<p><strong>其中JDK中提供的创建动态代理的机制，是以a 这种思路设计的，而cglib 则是以b思路设计的。</strong></p>
</blockquote>
<a id="more"></a>
<h3 id="jdk的实现方式"><a href="#jdk的实现方式" class="headerlink" title="jdk的实现方式"></a>jdk的实现方式</h3><h4 id="一、定义接口"><a href="#一、定义接口" class="headerlink" title="一、定义接口"></a>一、定义接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二、定义实现类"><a href="#二、定义实现类" class="headerlink" title="二、定义实现类"></a>二、定义实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"aaaadd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dddddel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、定义代理类，实现InvocationHandler接口"><a href="#三、定义代理类，实现InvocationHandler接口" class="headerlink" title="三、定义代理类，实现InvocationHandler接口"></a>三、定义代理类，实现InvocationHandler接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 三个参数：</span><br><span class="line">         * 1：要代理类的ClassLoader</span><br><span class="line">         * 2：要代理类有哪些方法（不但有自己实现的接口，还可能有父类实现的接口，所以为数组）</span><br><span class="line">         *    如果单一接口可以使用new Class[]&#123;UserService.class&#125;无问题,最好使用userService.getClass().getInterfaces()避免有继承则的情况</span><br><span class="line">         * 3：当前对象</span><br><span class="line">         *</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(proxy.hashCode());//报错</span></span><br><span class="line">        <span class="keyword">if</span> (proxy <span class="keyword">instanceof</span> Proxy)</span><br><span class="line">            System.out.println(<span class="string">"yes proxy"</span>);</span><br><span class="line">        System.out.println(<span class="string">"start..."</span>);</span><br><span class="line">        method.invoke(userService,args);</span><br><span class="line">        System.out.println(<span class="string">"end...."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserProxy userProxy = <span class="keyword">new</span> UserProxy();</span><br><span class="line">      	<span class="comment">//获取代理对象</span></span><br><span class="line">        Object proxy = userProxy.bind(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        Proxy proxy1 = (Proxy) proxy;</span><br><span class="line">        <span class="comment">//System.out.println(proxy1.hashCode());//报错</span></span><br><span class="line">      	<span class="comment">//强转为被代理类型</span></span><br><span class="line">        UserService userService = (UserService) proxy;</span><br><span class="line">        <span class="comment">//为什么$Proxy0.hashCode(Unknown Source)</span></span><br><span class="line">        <span class="comment">//System.out.println(userService.hashCode());//报错</span></span><br><span class="line">        userService.add();</span><br><span class="line">        userService.del();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="五、输出"><a href="#五、输出" class="headerlink" title="五、输出"></a>五、输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start...</span><br><span class="line">aaaadd</span><br><span class="line">end....</span><br><span class="line">start...</span><br><span class="line">dddddel</span><br><span class="line">end....</span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>调用代理对象proxy.hashCode()（userService.hashCode()）方法为什么报错？</p>
<p>​<img src="http://o8n1hrt12.bkt.clouddn.com/16-7-6/55200975.jpg" alt=""></p>
<p>而且在Client.main中注释掉对<code>add</code>和<code>del</code>的调用，报错同样打印<code>start..</code>和<code>end..</code>。如下所示    </p>
<p>​<img src="http://o8n1hrt12.bkt.clouddn.com/16-7-6/22858027.jpg" alt="">                        </p>
<p>​</p>
</li>
<li><p>同上使用IDEA  debug时会莫名执行invoke()中的方法？而直接run则没问题。</p>
</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="http://paddy-w.iteye.com/blog/841798" target="_blank" rel="external">InvocationHandler中invoke()方法的调用问题</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM的类加载机制]]></title>
      <url>http://4rnold.github.io/2016/07/04/JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="类的加载、链接和初始化"><a href="#类的加载、链接和初始化" class="headerlink" title="类的加载、链接和初始化"></a>类的加载、链接和初始化</h1><ul>
<li><p>加载：查找并加载二进制数据</p>
<blockquote>
<p>.class文件中的二进制数据读入到内存。放在<code>运行时数据区的方法区</code> 内，然后再<code>堆</code> 区创建一个java.lang.Class对象，封装类的数据结构，通过各个类在堆区的class对象就能实现对类的操作（反射什么的）。</p>
</blockquote>
</li>
</ul>
<ul>
<li>连接<ul>
<li>验证：类的正确性（确实是个java的类不是C++ 的）</li>
<li>准备：为<code>静态变量</code>分配空间并初始化<code>默认值</code>（还没有赋值，先赋为默认值）</li>
<li>解析：把类中<code>符号引用</code>转为<code>直接引用</code> （指针指向真正要执行方法的内存地址）</li>
</ul>
</li>
<li>初始化：静态变量赋<code>初始值</code> （前面是默认值）。</li>
</ul>
<a id="more"></a>
<p>在六种对类的第一次<code>主动使用</code>时才会去初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Test&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">6</span>/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//访问Test.x不运行，</span></span><br><span class="line">    <span class="comment">//如果x = new Random().nextInt(10)则运行此方法。</span></span><br><span class="line">    <span class="comment">//如果x不是final 则运行此方法。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassLoader.loadClass() 加载类不是对类的主动使用（仅仅加载不会调用初始化方法）</p>
<blockquote>
<p>TIPS : 加载匿名内部类可以使用诸如<code>“java.net.URLClassLoader$3$1”</code>表明URLClassLoader中第3个匿名内部类中的第一个匿名内部类</p>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li><p>java自带加载器</p>
<ul>
<li><p>根加载器（Bootstrap）所加载类的.getClassLoader()得到null</p>
<p>根加载器实现依赖底层操作系统。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>扩展类加载器（Extension）</p>
<p>​    从java.ext.dirs系统属性指定目录加载类库，或从JDK安装魔力jre/lib/ext目录加载</p>
</li>
<li><p>系统类加载器（System）</p>
<p>从环境变量classpath或java.class.path指定的目录中加载</p>
</li>
</ul>
<ul>
<li>用户自定义加载器（classloader的子类）</li>
</ul>
<p>加载类的加载器是<code>定义类加载器</code>，其子类加载器是<code>初始类加载器</code></p>
<p><strong>父加载器加载的类不能看见子加载器加载的类。</strong></p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = loadder1.loadClass(<span class="string">"Sample.class"</span>);</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        Sample sample = (Sample)object;<span class="comment">//报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中Client由System加载，Sample类由自定义类加载器（Loader1）加载，所以main中无法访问sample。可以使用<code>反射</code>方法来突破这种限制。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = loadder1.loadClass(<span class="string">"Sample.class"</span>);</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        Field field = clazz.getField(<span class="string">"v1"</span>);<span class="comment">//反射</span></span><br><span class="line">        <span class="keyword">int</span> v1 = field.getInt(object);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span> + v1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h2><p>当<code>自定义类加载器</code>加载的类的生命周期结束时，该类<code>方法区</code> 内的数据也会被<code>卸载</code>。</p>
<p>而<code>系统类加载器</code>(三种) 加载的类始终不会被卸载。</p>
<h2 id="引用变量与对象的引用关系"><a href="#引用变量与对象的引用关系" class="headerlink" title="引用变量与对象的引用关系"></a>引用变量与对象的引用关系</h2><p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-4/24473210.jpg" alt=""></p>
<p>(图引自：<a href="http://www.cnblogs.com/mengdd/p/3594608.html" target="_blank" rel="external">http://www.cnblogs.com/mengdd/p/3594608.html</a>)</p>
<p>卸载：Class对象被卸载，方法区类二进制数据被卸载（可以通过Class.hashCode()来判断）。（是否说明方法区内和Class对象是始终一一对应的？）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客文件名带&符号导致localsearch失效问题]]></title>
      <url>http://4rnold.github.io/2016/07/01/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%90%8D%E5%B8%A6%E7%AC%A6%E5%8F%B7%E5%AF%BC%E8%87%B4localsearch%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>之前有一篇名为“JavaWeb开发(1)——Servlet&amp;JSP”的文章，在hexo中对应的文件名为“JavaWeb开发(1)——Servlet&amp;JSP.md”,随后发现hexo localsearch 不能使用。查看配置无问题。</p>
<p>访问<a href="http://localhost:4000/search.xml" target="_blank" rel="external">http://localhost:4000/search.xml</a> 报如下错误<br><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-1/16203251.jpg" alt=""></p>
<p>逐个排查后发现md文件名不能带 <code>&amp;</code> 符号。</p>
<p>以后md文件还是避免使用符号为好。</p>
<p>另外，将文件名中&amp;转义为<code>&amp;amp;</code>后搜索功能可用。但是文章链接无法打开。因为hexo将md文件名作为当前文章的url，<code>&amp;amp;</code>转义后为&amp;，&amp;是url关键字。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[装饰器模式 和 代理模式 区别]]></title>
      <url>http://4rnold.github.io/2016/07/01/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%20%E5%92%8C%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%20%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<ul>
<li>装饰器是对现有对象的一种装饰</li>
<li>代理模式是直接生成一个代理对象。</li>
</ul>
<ul>
<li>装饰器是通过set方法传入对象，</li>
<li>代理模式是直接在初始化时new 一个对象。</li>
</ul>
<ul>
<li>装饰者建立后，修饰完a 还可以修饰b对象。</li>
<li>代理模式是创建后对象就确定了。就是建立一个代理A类的对象。</li>
</ul>
<p>貌似挺无聊的..都是包装了一层。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb开发(2)——cookie&session&EL&filter]]></title>
      <url>http://4rnold.github.io/2016/07/01/JavaWeb%E5%BC%80%E5%8F%91(2)%E2%80%94%E2%80%94cookie%20and%20session%20and%20EL%20and%20filter/</url>
      <content type="html"><![CDATA[<p><em>私人笔记仅作个人记录用</em></p>
<hr>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>当服务端传cookie到客户端（http头中的Set-Cookie字段），那么客户端后面的请求将携带cookie信息。<br>所以….==之前看到的静态文件推荐使用独立域名，可以避免访问静态文件也携带cookie，浪费网络带宽。==</p>
<h2 id="Cookie的作用范围"><a href="#Cookie的作用范围" class="headerlink" title="Cookie的作用范围"></a>Cookie的作用范围</h2><p>cookie.setPath(request.getContextPath());</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>只有调用 request.getSession() 或 request.getSession(true) 才创建session对象。</p>
<h2 id="session-的生命周期"><a href="#session-的生命周期" class="headerlink" title="session 的生命周期"></a>session 的生命周期</h2><p>在 tomcat中的web.xml可以设置 session最大时间</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="session-url-重写"><a href="#session-url-重写" class="headerlink" title="session url 重写"></a>session url 重写</h2><p>respose.encodeURL(“hello.jsp”) 会对将JSESSIONID附在url后面。</p>
<hr>
<h1 id="jsp-amp-servlet-路径问题"><a href="#jsp-amp-servlet-路径问题" class="headerlink" title="jsp&amp;servlet 路径问题"></a>jsp&amp;servlet 路径问题</h1><p>相对路径 servlet目录 和jsp 不一样，导致页面404，所以推荐使用绝对路径。</p>
<p>绝对路径涉及到 “/” 的使用：</p>
<p><strong>代表web应用路径的情况： (交给servlet容器处理)</strong></p>
<ul>
<li>请求转发： request.getRequestDispatcher(“/path/b.jsp”).forward(req,res);</li>
<li>web.xml 中映射Servlet 访问路径<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/abc<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代表站点根路径的情况： (交给浏览器处理)</strong></p>
<ul>
<li>超链接 <a herf="/webapp/a.jsp"></a></li>
</ul>
<p>通常使用request.getContextPath() 组合为绝对路径。</p>
<h1 id="EL-表达式"><a href="#EL-表达式" class="headerlink" title="EL 表达式"></a>EL 表达式</h1><ul>
<li><p>隐藏对象 </p>
<ul>
<li>pageScope</li>
<li>requestScope</li>
<li>sessionScope</li>
<li>applicationScope</li>
</ul>
</li>
<li><p>请求参数</p>
<ul>
<li>param</li>
<li>paramValues</li>
</ul>
</li>
<li><p>其他隐含对象</p>
<ul>
<li>cookie</li>
<li>header 请求头</li>
<li>headerValues</li>
<li>initParam</li>
<li>pageContext</li>
</ul>
</li>
</ul>
<p>==pageContext.session 和 sessionScope 区别??==</p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>过滤器中<code>&lt;dispathcer&gt;</code>节点指定过滤器所拦截的资源被<code>servlet容器</code>的调用方式。可以指定多个。</p>
<p>可以是REQUEST,INCLUDE,FORWARD,ERROR之一，默认REQUEST。</p>
<hr>
<blockquote>
<p>TIPS: 各种URL<br><img src="http://o8n1hrt12.bkt.clouddn.com/16-6-30/93659693.jpg" alt=""><br>request.getContextPath() 得到当前应用的路径</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb开发(1)——Servlet&JSP]]></title>
      <url>http://4rnold.github.io/2016/06/30/JavaWeb%E5%BC%80%E5%8F%91(1)%E2%80%94%E2%80%94Servlet%20and%20JSP/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>问题：针对新建的web工程，需要手动将编译好的类复制到<code>WEB-INF/classes</code>目录下。麻烦</strong></p>
<blockquote>
<p>Eclipse中Java Build Path &gt; Source 设置Default output folder 到 WEB-INFO/classes目录</p>
</blockquote>
<p><strong>问题：tomcat webapp目录如何映射到工程目录？</strong></p>
<blockquote>
<p>配置Tomcat <context>元素，不要直接在server.xml中配置<context>元素，<br>    因为tomcat启动后将不再读取server.xml，因此无法在Tomcat启动的状态下 发布web应用。</context></context></p>
<p>通过创建独立的xml文件的方式来配置<context>，Tomcat 以Xml文件名作为Web应用的上下文路径。<br>    忽略<context>中 path 属性。</context></context></p>
<p>在apache/conf/ 目录下建立catalina/localhost目录，该目录下建立<code>helloworld.xml</code>文件。其中helloworld为访问路径<a href="http://localhost:8080/`helloworld`/xxxx" target="_blank" rel="external">http://localhost:8080/`helloworld`/xxxx</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/test2"</span> <span class="attr">docBase</span>=<span class="string">""</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中path 为浏览器访问目录(无用)，docBase为WebApp所在目录（WebContent目录）。</p>
</blockquote>
<a id="more"></a>
<h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="servlet-配置"><a href="#servlet-配置" class="headerlink" title="servlet 配置"></a>servlet 配置</h2><p><strong>注意：</strong><servlet-mapping> 中的 <url-pattern> 如果带<em>的话只能是 `/</em><code>或 *加扩展名</code><em>.xxx` 其他带 </em>的均不合法</url-pattern></servlet-mapping></p>
<h2 id="servlet-生命周期"><a href="#servlet-生命周期" class="headerlink" title="servlet 生命周期"></a>servlet 生命周期</h2><blockquote>
<p>构造方法 -&gt; init方法 -&gt; service方法 -&gt; destory方法</p>
</blockquote>
<h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><p>init 方法参数</p>
<p>在<servlet>节点中配置<init-param>,可配置多组<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></init-param></servlet></p>
<p>通过servletConfig中的方法可以获取到其中的值。</p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>可通过ServletConfig.getServletContext 获取</p>
<p>该对象代表当前web应用，可以取到该应用的各方面信息</p>
<h3 id="1-获取web-xml中web应用配置参数"><a href="#1-获取web-xml中web应用配置参数" class="headerlink" title="1.获取web.xml中web应用配置参数"></a>1.获取web.xml中web应用配置参数<context-param></context-param></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>相对于<init-param>，<context-param>可看作的全局参数。</context-param></init-param></p>
<h3 id="2-getRealPath-String-path"><a href="#2-getRealPath-String-path" class="headerlink" title="2.getRealPath(String path)"></a>2.getRealPath(String path)</h3><p>获取发布在服务器上的绝对路径</p>
<p>可用于查找eclipse在本地真正发布项目的位置</p>
<h3 id="3-getContextPath"><a href="#3-getContextPath" class="headerlink" title="3.getContextPath()"></a>3.getContextPath()</h3><p>获取当前web 应用名称</p>
<h3 id="4-getResourceAsStream-String-path"><a href="#4-getResourceAsStream-String-path" class="headerlink" title="4.getResourceAsStream(String path)"></a>4.getResourceAsStream(String path)</h3><p>获取某一文件对应的输入流</p>
<h2 id="ServletRequest-amp-ServletResponse"><a href="#ServletRequest-amp-ServletResponse" class="headerlink" title="ServletRequest &amp; ServletResponse"></a>ServletRequest &amp; ServletResponse</h2><p>service方法参数</p>
<p>这是两个接口，不同的servlet容器具体实现，传入service方法。</p>
<p><code>HttpServletRequest</code> 是 <code>ServletRequest</code> 子接口，封装http相关信息</p>
<h2 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h2><p>实现了<code>Servlet</code>接口。为了让子类不重写所有的servlet中的方法。</p>
<p>同时实现了<code>ServletConfig</code>接口，所以可以在service方法中直接方便使用 ServletConfig 对象的方法。 </p>
<blockquote>
<p>TIPS :IDEA 不能自动下载servlet-api源码（建立的Web Application 工程），显示从maven上没有搜索到。需要手工从<a href="http://tomcat.apache.org/index.html" target="_blank" rel="external">http://tomcat.apache.org/index.html</a> 下载源码后加载。</p>
</blockquote>
<h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><p>HttpServlet 继承 GenericServlet，重载service方法，将ServletRequest 和 ServletResponse 转为 HttpServletRequest 和 HttpServletResponse。<br>并根据请求分出 doGet和 doPost方法。</p>
<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="JSP-隐含对象"><a href="#JSP-隐含对象" class="headerlink" title="JSP 隐含对象"></a>JSP 隐含对象</h2><ul>
<li>request：HttpServletRequest</li>
<li><del>response</del>：HttpServletResponse（在jsp页面基本不用）</li>
<li>pageContext：页面上下文</li>
<li>session: HttpSession</li>
<li>application: servletContext，当前web应用。</li>
<li><del>config</del>：对应servlet中的servletConfig 可以获取配置参数，那么问题来了..</li>
</ul>
<p><strong>问题： jsp页面的参数则呢配置？</strong></p>
<blockquote>
<p>同普通servlet一样，只需要将原来<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.arnold.Test.MyFirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">&gt; 替换为</span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">jsp-file</span>&gt;</span>/hello.jsp<span class="tag">&lt;/<span class="name">jsp-file</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>因为jsp本质也是一个servlet类么..但这样就只能通过访问servletName来访问此jsp</p>
</blockquote>
<ul>
<li>out: JspWriter, 调用out.println()可以直接打印</li>
<li><del>page</del>: 为object对象 基本不用。</li>
<li>exception: jsp页面声明&lt;%@ page isErrorPage=”true” %&gt;才可用</li>
</ul>
<h2 id="JSP-内置对象作用范围"><a href="#JSP-内置对象作用范围" class="headerlink" title="JSP 内置对象作用范围"></a>JSP 内置对象作用范围</h2><ul>
<li>pageContext : 当前jsp页面</li>
<li>request： 同一个请求</li>
<li>session： 同一个回话</li>
<li>application： 同一个应用</li>
</ul>
<h2 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h2><ul>
<li>session： 当前页面是否允许使用session</li>
<li>ErrorPage：指定错误页面指向，然后错误页面要使用isErrorPage=true,使用exception对象</li>
</ul>
<blockquote>
<p>TIPS: errorPage.jsp 一般不能直接方法，所以放到WEB-INF中，通过forward转发可以访问。</p>
<p>TIPS: 通常在web.xml中配置错误页面信息<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span><span class="comment">&lt;!--可根据错误代码或异常类型判断--&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">location</span>&gt;</span>/WEB-INFO/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>contentType：实际调用的response.setContentType</li>
<li>pageEncoding: 当前jsp页面的字符编码，通常和contentType的charset一致</li>
</ul>
<blockquote>
<p>TIPS: <a href="http://my.oschina.net/chape/blog/138828" target="_blank" rel="external">contentType和pageEncoding的区别</a></p>
</blockquote>
<h2 id="include指令静态引入"><a href="#include指令静态引入" class="headerlink" title="include指令静态引入"></a>include指令静态引入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=&quot;url&quot;%&gt;</span><br></pre></td></tr></table></figure>
<p>静态包含，最后只生成<code>一个class</code>。</p>
<h2 id="动态引入"><a href="#动态引入" class="headerlink" title="动态引入"></a><jsp:include>动态引入</jsp:include></h2><p>生成两个class</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><jsp:forward></jsp:forward></h2><p>相当于request.getRequestDispathcer(“b.jsp”).forward(request,response);</p>
<h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forward 一次请求</span></span><br><span class="line">String path = <span class="string">"testPath"</span>;</span><br><span class="line">RequestDispatcher requestDispatcher = request.getRequestDispatcher(<span class="string">"/"</span> + path);</span><br><span class="line">requestDispatcher.forward(request,response);</span><br><span class="line"></span><br><span class="line"><span class="comment">//redirect 两次请求(网址会变)</span></span><br><span class="line">response.sendRedirect(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>forward是发送给web容器，然后web容器转发</strong>，Request对象不变。</li>
<li>redirect是浏览器302转发。</li>
</ul>
<p>forward “/” 代表当前web应用的根目录<br>redirect “/” 代表当前web站点的根目录</p>
]]></content>
    </entry>
    
  
  
</search>
