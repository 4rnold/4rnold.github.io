<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[js跨域问题]]></title>
      <url>http://4rnold.github.io/2016/07/27/js%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="jsonp跨域"><a href="#jsonp跨域" class="headerlink" title="jsonp跨域"></a>jsonp跨域</h1><p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-27-10-07-44.png" alt=""> </p>
<p>通过远程调用js方法将json数据放在callback()方法中返回。</p>
<a id="more"></a>
<p>springmvc controller端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(HttpServletRequest req,HttpServletResponse res)</span> </span>&#123;</span><br><span class="line">  res.setContentType(<span class="string">"text/plain"</span>);</span><br><span class="line">  String callbackFunName =req.getParameter(<span class="string">"callbackparam"</span>);<span class="comment">//得到js函数名称</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res.getWriter().write(callbackFunName + <span class="string">"([ &#123; name:\"John\"&#125;])"</span>); <span class="comment">//返回jsonp数据</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getJsonp"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONPObject <span class="title">getJsonp</span><span class="params">(String callbackparam)</span></span>&#123;</span><br><span class="line">  Company company=<span class="keyword">new</span> Company();</span><br><span class="line">  company.setAddress(<span class="string">"广州天河华景软件园"</span>);</span><br><span class="line">  company.setEmail(<span class="string">"123456@qq.com"</span>);</span><br><span class="line">  company.setName(<span class="string">"广州讯动网络可以有限公司"</span>);</span><br><span class="line">  company .setPhone(<span class="string">"12345678912"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JSONPObject(callbackparam, company); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ajax端</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-2.1.3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">$("#but1").click(function()&#123;</span><br><span class="line">     $.ajax(&#123;</span><br><span class="line">		url:'http://127.0.0.1:8080/DevInfoWeb/get',</span><br><span class="line">		type: "get",</span><br><span class="line">		async: false,</span><br><span class="line">		dataType: "jsonp",</span><br><span class="line">		jsonp: "callbackparam", //服务端用于接收callback调用的function名的参数 </span><br><span class="line">		jsonpCallback: "success_jsonpCallback", //callback的function名称,服务端会把名称和data一起传递回来 </span><br><span class="line">		success: function(json) &#123;</span><br><span class="line">		 alert(json);</span><br><span class="line">		&#125;,</span><br><span class="line">		error: function()&#123;alert('Error');&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$("#but2").click(function()&#123;</span><br><span class="line">     $.ajax(&#123;</span><br><span class="line">		url:'http://127.0.0.1:8080/DevInfoWeb/getJsonp',</span><br><span class="line">		type: "get",</span><br><span class="line">		async: false,</span><br><span class="line">		dataType: "jsonp",</span><br><span class="line">		jsonp: "callbackparam", //服务端用于接收callback调用的function名的参数 </span><br><span class="line">		jsonpCallback: "success_jsonpCallback", //callback的function名称,服务端会把名称和data一起传递回来 </span><br><span class="line">		success: function(json) &#123;</span><br><span class="line">		 alert(json);</span><br><span class="line">		&#125;,</span><br><span class="line">		error: function()&#123;alert('Error');&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>使用 jQuery AJAX 来改变文本<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"but1"</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"but2"</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="启用-CORS-解决跨域"><a href="#启用-CORS-解决跨域" class="headerlink" title="启用 CORS 解决跨域"></a>启用 CORS 解决跨域</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>​    服务器端直接设置header内容<br><strong>Access-Control-Allow-Origin：*</strong><br>​    或者<br><strong>Access-Control-Allow-Origin：</strong>htt@p://<a href="http://api.zhihu.com" target="_blank" rel="external">http://api.zhihu.com</a><br>​    这样就可以直接请求到任何网站或者htt@p://<a href="http://api.zhihu.com" target="_blank" rel="external">http://api.zhihu.com</a><br>php程序这样写：<br>​    header(‘Access-Control-Allow-Origin：*’);<br>或者<br>​    header(‘Access-Control-Allow-Origin：htt@p://api.zhihu.com’);<br>（注意去掉@，知乎编辑器不知道怎么不让带http的网址自动链接，先这样写了）</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>​    在Nginx设置”头信息“直接添加<strong>Access-Control-Allow-Origin：*</strong>的信息。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.zhihu.com/question/19618769/answer/24819290?from=profile_answer_card" target="_blank" rel="external">如何解决 Ajax 跨域请求不到的问题？</a></li>
</ul>
<ul>
<li><a href="http://blog.csdn.net/caiwenfeng_for_23/article/details/45300739" target="_blank" rel="external">Ajax+Spring MVC实现跨域请求（JSONP）</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM笔记]]></title>
      <url>http://4rnold.github.io/2016/07/23/JVM%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="JVM-启动流程"><a href="#JVM-启动流程" class="headerlink" title="JVM 启动流程"></a>JVM 启动流程</h1><p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-22-09-32-45.png" alt=""> </p>
<a id="more"></a>
<h1 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h1><p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-22-09-33-44.png" alt=""></p>
<h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><ul>
<li>每个线程有一个pc寄存器</li>
<li>指向下一条地址</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li>保存类的源信息<ul>
<li>类字节码</li>
<li>常量</li>
</ul>
</li>
</ul>
<h2 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h2><ul>
<li>对象都放在堆区</li>
<li>所有线程共享堆（大小共享，内容不共享吧）</li>
<li>GC主要工作区域</li>
</ul>
<h2 id="JAVA栈"><a href="#JAVA栈" class="headerlink" title="JAVA栈"></a>JAVA栈</h2><ul>
<li>线程私有</li>
<li>由一系列帧组成</li>
<li>帧保存局部变量，操作数栈，常量池指针</li>
</ul>
<blockquote>
<p>当static方法调用时参数入栈，非static方法调用首先将<strong>this引用入栈</strong> 再将各参数入栈</p>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-22-09-45-39.png" alt=""> </p>
</blockquote>
<ul>
<li>操作数栈</li>
</ul>
<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-22-21-43-09.png" alt=""> </p>
<p>每个线程会有自己的本地内存，来存放变量副本。</p>
<blockquote>
<p><em>如果线程A修改了变量的值，那线程B如何才能及时读取到呢？</em></p>
<p>答：使用volatile标示变量。</p>
</blockquote>
<h1 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h1><h2 id="引用计算法"><a href="#引用计算法" class="headerlink" title="引用计算法"></a>引用计算法</h2><p>记录对象引用数量，根对象引用不可达就回收。</p>
<p>缺点：1、性能低；2、不能解决循环引用的问题。</p>
<h2 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h2><p>标记阶段：根节点搜索可达则标记</p>
<p>清除：未标记的就清除 </p>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-22-23-56-48.png" alt=""></p>
<h2 id="标记-压缩法"><a href="#标记-压缩法" class="headerlink" title="标记-压缩法"></a>标记-压缩法</h2><p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-22-23-58-05.png" alt=""></p>
<p>相对于</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>两块内存空间，浪费空间</p>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-22-23-59-42.png" alt=""> </p>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-23-00-03-37.png" alt=""> </p>
<p>大对象直接放入老年代存货很久的放入老年代。</p>
<blockquote>
<p>少量对象存活，适合复制算法</p>
<p>大量对象存活，适合标记清理或标记压缩。</p>
</blockquote>
<h2 id="根"><a href="#根" class="headerlink" title="根"></a>根</h2><ul>
<li>栈中引用的对象</li>
<li>方法区中静态成员或常量引用（全局对象）</li>
<li>JNI方法栈中引用对象</li>
</ul>
<h1 id="GC参数"><a href="#GC参数" class="headerlink" title="GC参数"></a>GC参数</h1><h2 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h2><p>-xx:+UseSerialGC</p>
<ul>
<li>新生代、老年代使用串行回收</li>
<li>新生代：复制算法</li>
<li>老年代：标记-压缩</li>
</ul>
<h2 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h2><p>-xx:+UseParNewGC</p>
<ul>
<li>新生代：并行</li>
<li>老年代：串行</li>
</ul>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-23-00-53-59.png" alt=""> </p>
<h1 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h1><p>见：<a href="http://4rnold.github.io/2016/07/04/JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">http://4rnold.github.io/2016/07/04/JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</a></p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>竞争不激烈，提升性能。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>BasicObjectLock</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul>
<li>减小锁持有时间</li>
<li>减小锁粒度</li>
</ul>
<p>使用concurrentHashMap，将map分为多个segment，锁的时候只锁一个segment</p>
<ul>
<li><p>锁分离，读写锁分离</p>
<p>LinkedBlockQueue,分离take put锁</p>
</li>
</ul>
<ul>
<li><p>锁粗化</p>
<p>合并同一方法中的锁。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[memcached笔记]]></title>
      <url>http://4rnold.github.io/2016/07/21/memcached%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h1><p>为了克服内存碎片化，引入 slab chunk的内存机制<br><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-21-15-36-41.png" alt=""> </p>
<a id="more"></a>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-21-15-42-57.png" alt=""> </p>
<p>显示 chunk的大小和每个slab中chunk的数量<br>可以调整增长因子来调整chunk增加的大小。<br>如果有一个100k的内容会分配到122kchunk中，但122k chunk满了，不会去找更大的，而是把122中不常用的踢掉。使用LRU算法</p>
<h1 id="过期和删除机制"><a href="#过期和删除机制" class="headerlink" title="过期和删除机制"></a>过期和删除机制</h1><ul>
<li>过期后只是失效<br><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-21-15-59-26.png" alt=""> </li>
<li>取值的时候才判断是否过期，过期了才会影响curr_items的值</li>
</ul>
<p>节省了cpu资源</p>
<p>删除使用LRU算法删除最近未使用的</p>
<p><strong>key value长度限制</strong> ： key最大250字节，value 1m</p>
<p>#一致性哈希</p>
<p>解决的问题：当集群机器数量变化时，计算的key不变。</p>
<blockquote>
<p>服务器由n台变为n-1台后，原来的没n<em>(n-1)个key，现在还有n个key命中。命中率为n/n</em>(n-1)= 1/n-1 !</p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><p>大访问量的网站，网站刚上线时，短时间内缓存就满了，导致缓存到期时间一样，所以就周期性的出现 缓存集体失效。导致数据库周期性压力。</p>
</li>
<li><p>当多个memcached服务器，相同业务的key应具有相同的前缀，尽量使他们放在同一台机器上，减少服务器的链接，提高程序性能。</p>
</li>
<li><p>永久数据被删除现象</p>
</li>
</ul>
<blockquote>
<p>UC在2011年以前采用得较多的V1.3.0以及V1.2.5、V1.2.6，这些版本在配置的内存总量用完后，不检查队列尾的（较少访问的）数据是否有过期的，直接踢出队列尾部第一条数据，用来存放新数据。所以老版本的LRU机制是粗放，不够合理的。</p>
<p>而从V1.4.4开始（更早些的V1.4.*版本没确认），会先检查队列尾部（较少访问的）50条数据，淘汰掉过期数据，如果全都没过期，才会踢出队列尾部第一条数据。</p>
</blockquote>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="http://www.cnblogs.com/suredandan/archive/2013/07/21/3204159.html" target="_blank" rel="external">memcached的最佳实践方案</a></li>
<li><a href="http://tech.uc.cn/?p=323" target="_blank" rel="external">讲几个Memcached旧版本几个故事，你就明白怎么用了</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java并发编程]]></title>
      <url>http://4rnold.github.io/2016/07/21/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>两种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"111"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"2222"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>使用synchronized使资源互斥</p>
<p>synchronized(this)锁当前对象（多个new 不互斥），synchronized(class)是锁这个类的这个代码。</p>
<p><code>synchronized</code> <code>void</code> <code>f() { ``/* body */ }</code>和<code>void f() { synchronized(this) { /* body */</code> <code>} }</code>是完全等价的。</p>
<p>对于static synchronized 由于没有new 对象不存在 this，所以锁的是class对象</p>
<p>不同的方法同步可以将不同的方法放在<strong>同一个class中</strong>。这样互斥方便。</p>
<p>线程同步如何避免线程1让出资源，线程2没拿到，线程1又拿到了的情况？</p>
<p>设定一个boolean的参数，线程1执行完设为false并this.notify()通知其他线程，等线程2执行完设为true，线程1判断false就this.wait(),</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">synclass</span> </span>&#123;</span><br><span class="line">  <span class="comment">//控制执行顺序</span></span><br><span class="line">  <span class="keyword">boolean</span> synTag = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!synTag) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">      <span class="comment">//dosomething1</span></span><br><span class="line">      <span class="comment">//唤醒其他线程</span></span><br><span class="line">      <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (synTag) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//dosomething2</span></span><br><span class="line">      <span class="comment">//唤醒其他线程</span></span><br><span class="line">      <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是if是有问题的，this.wait() 会被<strong>伪唤醒</strong> </p>
<blockquote>
<p>线程T将会停止执行进入休眠状态，直到下面4中情况之一发生为止：<br>1.其他线程在这个对象上调用了notify方法，而且线程T被选中为要唤醒的线程<br>2.其他线程在这个对象上调用了notifyAll方法<br>3.其他线程调用了这个线程的interrupt方法<br>4.指定的时间到了。另外，如果参数timeout是0，相当于没有指定时间，线程的唤醒就和时间无关了<br>线程T被唤醒时，会从object的等待集合中退出，重新进入可执行队列中。它会和之前一样去和其他线程竞争获取object的同步权利；一旦线程获取了object的控制权，它在这个object上的同步权利就会恢复到wait调用之前的状态。线程会接着从调用wait的地方继续执行。因此，从wait方法返回之后，线程T和object的同步状态都正确的回到了wait方法调用时的状态。<br>一个线程也可以在上述4中情况之外醒来，这被称为伪唤醒(spurious wakeup).虽然这在实践中很少发生，程序还是必须要防止这种情况，通过条件测试来验证被唤醒的线程是否应该继续wait还是running。换句话说，<strong>waits应该总是出现在循环中</strong>，像下面这样：<br>    synchronized(obj) {<br>        while (适合1处执行的条件不成立) {<br>            obj.wait(timeout);<br>        }</p>
<pre><code>    //1
} 
</code></pre></blockquote>
<p>ThreadLocal 构建map对象，以线程id和变量名为key，可以从不同线程取到自己线程的数据。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dosomethings</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>线程池通过submit 传入一个 callable对象，可以返回Future对象，通过get方法得到结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//callable 和 future</span></span><br><span class="line">ExecutorService threadPool2 = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Object&gt; future = threadPool2.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Object res = future.get();<span class="comment">//阻塞的等待结果</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交多个任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一系列任务，执行完的先返回</span></span><br><span class="line">ExecutorService threadPool3 = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">CompletionService&lt;Object&gt; comService = <span class="keyword">new</span> ExecutorCompletionService&lt;Object&gt;(threadPool3);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">10</span> ;i++) &#123;</span><br><span class="line">  comService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">10</span> ;i++) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object res = comService.take().get();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock 可以代替 synchronized，但还是推荐使用synchronized，除非用到lock中特殊的特性时。</p>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">       <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">       <span class="comment">//申请写锁必须释放读锁</span></span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">       rwl.writeLock().lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">         <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">         <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">           data = ...</span><br><span class="line">           cacheValid = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">         rwl.readLock().lock();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>申请写锁前必须释放读锁</strong> 所以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rwl.readLock().unlock();</span><br><span class="line">rwl.writeLock().lock();</span><br><span class="line"><span class="comment">//不能写为如下，这样的意义是持有读锁的A在和什么都没有的B同时申请写锁时没有任何竞争优势。不能从读锁升级为写锁</span></span><br><span class="line">rwl.writeLock().lock();</span><br><span class="line"><span class="comment">//所以此处有空隙</span></span><br><span class="line">rwl.readLock().unlock();</span><br><span class="line"><span class="comment">//因为上面的空隙所以要进一步判断 if (!cacheValid) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而写锁可以降为读锁。</span></span><br></pre></td></tr></table></figure>
<p>this.wait() this.notify() 可以换为 condition.await() condition.signal();</p>
<p>condition可以多路阻塞，有多个锁的情况，看condition api中的demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h1><p>Semaphore</p>
<p>控制访问自身线程的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Semaphore sp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);<span class="comment">//可以设置是否按先来后到</span></span><br><span class="line">sp.acquire();<span class="comment">//获取，获取不到阻塞</span></span><br><span class="line">sp.release();<span class="comment">//释放</span></span><br></pre></td></tr></table></figure>
<p>CyclicBarrier</p>
<p>集合好后出发，先到阻塞</p>
<p>CountDownLatch</p>
<p>计数器同步</p>
<p>Exchanger</p>
<p>两线程交换数据</p>
<p>ArrayBlockingQueue</p>
<p>阻塞队列，原理就是上面condition api中的代码</p>
<p>SynchronousQueue</p>
<p>无缓冲，</p>
<p>ConcurrentHashMap</p>
<p>传统集合不支持多线程</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.csdn.net/xiao__gui/article/details/8188833" target="_blank" rel="external">Java线程同步：synchronized锁住的是代码还是对象</a></li>
</ul>
<ul>
<li><a href="http://blog.csdn.net/allenf7/article/details/23297297" target="_blank" rel="external">一个阻塞队列引发的死锁和伪唤醒</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC学习笔记]]></title>
      <url>http://4rnold.github.io/2016/07/09/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="springmvc-helloworld"><a href="#springmvc-helloworld" class="headerlink" title="springmvc helloworld"></a>springmvc helloworld</h2><h3 id="一、DispathchServlet-配置"><a href="#一、DispathchServlet-配置" class="headerlink" title="一、DispathchServlet 配置"></a>一、DispathchServlet 配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="comment">&lt;!-- 如果不配置则默认使用/WEB-INF/xxxx-servlet.xml--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="二、配置springmvc-xml"><a href="#二、配置springmvc-xml" class="headerlink" title="二、配置springmvc.xml"></a>二、配置springmvc.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">beans:property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span>  <span class="comment">&lt;!--forward到对应的jsp--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:bean</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--扫描包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.xxxx"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="SpringMVC-REST"><a href="#SpringMVC-REST" class="headerlink" title="SpringMVC REST"></a>SpringMVC REST</h2><p><code>HiddenHttpMethodFilter</code>可以将post请求转为put请求和Delete请求。</p>
<h3 id="配置Filter"><a href="#配置Filter" class="headerlink" title="配置Filter"></a>配置Filter</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>    </span><br><span class="line">  	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>    </span><br><span class="line">  	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>    </span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Delete和Put请求"><a href="#Delete和Put请求" class="headerlink" title="Delete和Put请求"></a>Delete和Put请求</h3><p>表单增加隐藏域<code>_method</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"DELETE"</span>/&gt;</span> <span class="comment">&lt;!--或value=PUT--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h2><ul>
<li>PathVariable : 从url中{id}获取参数</li>
<li>RequestParam : 绑定请求参数@RequestParam(“id”) int id;  可设置 required defaultValue</li>
<li>RequestHeader</li>
<li>CookieValue</li>
</ul>
<ul>
<li>ModelAndView<blockquote>
<p>ModelAndView源代码中是把其中Attribute一个一个放到request中去，所以我们可以在jsp页面访问</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>controller上map参数会自动加入到ModelAndView中  </p>
</blockquote>
<ul>
<li>SessionAttributes</li>
</ul>
<blockquote>
<p>在控制器类上添加，将Request中指定的（可以根据<code>属性名</code>或<code>属性类型</code>）属性加入到Session中</p>
</blockquote>
<ul>
<li>ModelAttribute</li>
</ul>
<blockquote>
<p>在Controller的一个方法上，在执行此Controller每个方法前调用，可以往Map里放初始值（map键值需要和目标方法入参类名第一个字母小写一致）</p>
</blockquote>
<h2 id="POJO绑定流程"><a href="#POJO绑定流程" class="headerlink" title="POJO绑定流程"></a>POJO绑定流程</h2><p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-7/19566832.jpg" alt=""></p>
<h2 id="配置直接转发页面"><a href="#配置直接转发页面" class="headerlink" title="配置直接转发页面"></a>配置直接转发页面</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/success"</span> <span class="attr">view-name</span>=<span class="string">"success"</span>/&gt;</span> <span class="comment">&lt;!--直接转发到success.jsp--&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置上述配置后，经过handler处理的请求404，需要再配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义视图"><a href="#自定义视图" class="headerlink" title="自定义视图"></a>自定义视图</h2><h3 id="一、实现自定义view，集成view接口"><a href="#一、实现自定义view，集成view接口" class="headerlink" title="一、实现自定义view，集成view接口"></a>一、实现自定义view，集成view接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"text/html"</span>;<span class="comment">//返回内容类型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; map, javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//渲染视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、配置视图解析器"><a href="#二、配置视图解析器" class="headerlink" title="二、配置视图解析器"></a>二、配置视图解析器</h3><p>配置BeanNameViewResolver，使用视图的名字解析视图</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><h3 id="一、继承Converter"><a href="#一、继承Converter" class="headerlink" title="一、继承Converter"></a>一、继承Converter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Target</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Target <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Traget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、配置ConversionService"><a href="#二、配置ConversionService" class="headerlink" title="二、配置ConversionService"></a>二、配置ConversionService</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置ConversionServiceFactoryBean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"testConverter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注入进去--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="annotation-driven"><a href="#annotation-driven" class="headerlink" title="annotation-driven"></a>annotation-driven</h2><p>三个坑要使用<code>&lt;mvc:annotation-driven&gt;</code> </p>
<p>一、 使用<code>&lt;mvc:view-controller&gt;</code> 后正常handler不能映射，404</p>
<p>二、为处理静态资源问题，配置<code>&lt;mvc:default-servlet-handler/&gt;</code> 后handler不能映射</p>
<blockquote>
<p>配置<mvc:default-servlet-handler> 后，handlerAdapters中没有<code>AnnotationMethodHandlerAdapter</code>（已过期）</mvc:default-servlet-handler></p>
<p>添加annotation-driven后增加了RequestMappingHandlerAdapter，所以@RequestMapping又起作用了。</p>
</blockquote>
<p>三、配置ConversionService</p>
<h3 id="annotation-driven作用"><a href="#annotation-driven作用" class="headerlink" title="annotation-driven作用"></a>annotation-driven作用</h3><p>自动注册三个bean</p>
<ul>
<li>RequestMappingHandlerMapping</li>
<li>RequestMappingHandlerAdapter</li>
<li>ExceptionHandlerExceptionResolver</li>
</ul>
<p>提供以下支持</p>
<ul>
<li>ConversionService</li>
<li>@NumberFormatannotation @DateTimeFormat 数据格式化（或string接收再转换）</li>
<li>@Valid javaBean验证（也可以配置LocalValidatorFactoryBean 支持JSR303）</li>
<li>@RequestBody和@ResponseBody</li>
</ul>
<h2 id="initBinder"><a href="#initBinder" class="headerlink" title="@initBinder"></a>@initBinder</h2><p>初始化WebDataBinder（权限id和集合映射）</p>
<h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h2><p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-7/35838270.jpg" alt=""></p>
<p>加入Jackson包后，messageConverters自动加载MappingJackson2HttpMessageConverter</p>
<p>@RequestBody@ResponseBody（或者使用HttpEntity<t> ResponseEntity<t>作为入参或返回类型） 会根据参数类型选择对应的MessageConverter</t></t></p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>配置MultipartResolver的一个实现类，<code>CommonsMultipartResovler</code></p>
<p>控制器方法中使用MultipartFile接收参数</p>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="拦截器配置"><a href="#拦截器配置" class="headerlink" title="拦截器配置"></a>拦截器配置</h3><p>一、实现<code>HandlerInterceptor</code>接口</p>
<p>二、springmvc.xml中的<code>&lt;mvc:interceptors&gt;</code>中配置拦截器bean</p>
<h3 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h3><p>在DispatcherServlet中的doDispatch()方法中 进行拦截</p>
<ul>
<li>prehandle</li>
<li>postHandle: 目标方法之后，渲染视图方法之前调用</li>
<li>afterCompletion: 渲染视图之后调用</li>
</ul>
<h3 id="多拦截器顺序"><a href="#多拦截器顺序" class="headerlink" title="多拦截器顺序"></a>多拦截器顺序</h3><p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-8/97156614.jpg" alt=""></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>通过HandlerExceptionResolver处理异常</p>
<p>配置了<mvc:annotation-driven>就配置了ExceptionHandlerExceptionResolver</mvc:annotation-driven></p>
<h3 id="ExceptionHandlerExceptionResolver"><a href="#ExceptionHandlerExceptionResolver" class="headerlink" title="ExceptionHandlerExceptionResolver"></a>ExceptionHandlerExceptionResolver</h3><p>在controller中新建处理异常的方法使用@ExceptionHandler标注</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;Exception.class&#125;)<span class="comment">//定义截获的exception类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">exHandler</span><span class="params">(Exception ex)</span> </span>&#123;<span class="comment">//可返回modelandview展示</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>).addObject(<span class="string">"ex"</span>,ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上只能截获当前controller中的异常</p>
<p>通过定义@ControllerAdvice标记的类中定义@ExceptionHandler可以全局截获</p>
<h3 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h3><p>可以标注在自定义exception上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(value = HttpStatus.BAD_REQUEST,reason = <span class="string">"自定义"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在抛出此异常时会携带自定义信息。</p>
<h3 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h3><p>默认的对spring的异常处理。</p>
<h2 id="SpringMVC运行流程"><a href="#SpringMVC运行流程" class="headerlink" title="SpringMVC运行流程"></a>SpringMVC运行流程</h2><p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-8/5769044.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://gloveangels.com/spring-mvc-access-static-resources-jpgjscss/" target="_blank" rel="external">SPRING-MVC 访问静态文件, 如 jpg/js/css（三种处理静态资源的方式）</a></p>
</li>
<li><p><a href="http://blog.csdn.net/madun/article/details/8988860" target="_blank" rel="external">Spring ContextLoaderListener与DispatcherServlet所加载的applicationContext的区别</a></p>
<p>​</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring事务管理]]></title>
      <url>http://4rnold.github.io/2016/07/06/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-6/79284388.jpg" alt=""></p>
<p>参考链接中介绍了物种配置方式，此处只记录最常用的<code>全注解方式</code></p>
<a id="more"></a>
<h2 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h2><p>一、配置事务管理器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> </span><br><span class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>二、启用事务注解</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>三、service上加@Transactional</p>
<h2 id="事务的传播属性和事务的隔离级别"><a href="#事务的传播属性和事务的隔离级别" class="headerlink" title="事务的传播属性和事务的隔离级别"></a>事务的传播属性和事务的隔离级别</h2><p>参照参考链接…</p>
<p>1： PROPAGATION_REQUIRED<br>加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务<br>比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，<br>ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA<br>的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。<br><strong>这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被 提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚</strong></p>
<p>为自己分配一个事务还涉及到methodA？？待测试..</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://blog.csdn.net/it_man/article/details/5074371" target="_blank" rel="external">Spring事务配置的五种方式和spring里面事务的传播属性和事务隔离级别</a></p>
<p>​</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AspectJ AOP]]></title>
      <url>http://4rnold.github.io/2016/07/06/AspectAOP/</url>
      <content type="html"><![CDATA[<p>连接点和切点的区别：连接点是数据库中的数据，切点是sql语句</p>
<p>AOP可以通过<code>AspectJ</code>和<code>xml</code>方式配置</p>
<h2 id="基于AspectJ配置方式"><a href="#基于AspectJ配置方式" class="headerlink" title="基于AspectJ配置方式"></a>基于AspectJ配置方式</h2><h3 id="一、配置AOP所需包"><a href="#一、配置AOP所需包" class="headerlink" title="一、配置AOP所需包"></a>一、配置AOP所需包</h3><p>maven仓库中加入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="二、实现接口和实现类"><a href="#二、实现接口和实现类" class="headerlink" title="二、实现接口和实现类"></a>二、实现接口和实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doSomethings"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、实现切面方法"><a href="#三、实现切面方法" class="headerlink" title="三、实现切面方法"></a>三、实现切面方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">//说明这是一个切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public void aop.impl.TestServiceImpl.doSomethings())"</span>)<span class="comment">//执行逻辑AspectJ表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过切面方法的<code>JoinPoint</code>可以获取所切连接点的信息（方法参数啥的..）。</p>
<ul>
<li>@After <ul>
<li>后置通知无论方法时候产生异常<strong>都会执行</strong></li>
<li>在@After中<strong>不能获得执行结果</strong></li>
</ul>
</li>
<li>AfterReturning: 正常执行后执行，括号中配置<code>returning=&quot;resutl&quot;</code>来获取结果</li>
<li>AfterThrowing: 异常通知，配置<code>throwing=&quot;ex&quot;</code>捕获异常</li>
<li>Around：环绕通知，其参数ProceedingJoinPoint 可以控制方法执行（可以代替以上所有通知）</li>
</ul>
<p>按手写动态代理invoke方法的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//前置通知</span></span><br><span class="line">  result = method.invoke(xxx);</span><br><span class="line">  <span class="comment">//返回通知，访问结果</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">  <span class="comment">//异常通知，捕获异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置通知</span></span><br></pre></td></tr></table></figure>
<h3 id="四、xml配置AspectJ"><a href="#四、xml配置AspectJ" class="headerlink" title="四、xml配置AspectJ"></a>四、xml配置AspectJ</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"aop"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使@Before生效，自动为匹配的类生成代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="切面执行顺序"><a href="#切面执行顺序" class="headerlink" title="切面执行顺序"></a>切面执行顺序</h2><p>通过@order(1)来指定</p>
<h2 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//定义切入点表达式</span></span><br><span class="line">  	<span class="meta">@Pointcut</span>(<span class="string">"execution(public void aop.impl.TestServiceImpl.doSomethings())"</span>)</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jointPointExpression</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//使用接入点表达式，不同类中引入报名类名即可</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"jointPointExpression()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过xml配置切入点"><a href="#通过xml配置切入点" class="headerlink" title="通过xml配置切入点"></a>通过xml配置切入点</h2><p>使用<code>&lt;aop:config&gt;</code>来配置，具体略..</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JDK动态代理]]></title>
      <url>http://4rnold.github.io/2016/07/06/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>动态代理JDK和cglib都为我们提供了现成的解决方案</p>
<blockquote>
<p><strong>代理Proxy 和RealSubject 应该实现相同的功能，这一点相当重要。（我这里说的功能，可以理解为某个类的public方法）</strong></p>
<p>在面向对象的编程之中，如果我们想要约定Proxy 和RealSubject可以实现相同的功能，有两种方式：</p>
<blockquote>
<p>   a.一个比较直观的方式，就是定义一个功能接口，然后让Proxy 和RealSubject来实现这个接口。</p>
<p>   b.还有比较隐晦的方式，就是通过继承。因为如果Proxy 继承自RealSubject，这样Proxy则拥有了RealSubject的功能，Proxy还可以通过重写RealSubject中的方法，来实现多态。</p>
</blockquote>
<p><strong>其中JDK中提供的创建动态代理的机制，是以a 这种思路设计的，而cglib 则是以b思路设计的。</strong></p>
</blockquote>
<a id="more"></a>
<h3 id="jdk的实现方式"><a href="#jdk的实现方式" class="headerlink" title="jdk的实现方式"></a>jdk的实现方式</h3><h4 id="一、定义接口"><a href="#一、定义接口" class="headerlink" title="一、定义接口"></a>一、定义接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二、定义实现类"><a href="#二、定义实现类" class="headerlink" title="二、定义实现类"></a>二、定义实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"aaaadd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dddddel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、定义代理类，实现InvocationHandler接口"><a href="#三、定义代理类，实现InvocationHandler接口" class="headerlink" title="三、定义代理类，实现InvocationHandler接口"></a>三、定义代理类，实现InvocationHandler接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 三个参数：</span><br><span class="line">         * 1：要代理类的ClassLoader</span><br><span class="line">         * 2：要代理类有哪些方法（不但有自己实现的接口，还可能有父类实现的接口，所以为数组）</span><br><span class="line">         *    如果单一接口可以使用new Class[]&#123;UserService.class&#125;无问题,最好使用userService.getClass().getInterfaces()避免有继承则的情况</span><br><span class="line">         * 3：当前对象</span><br><span class="line">         *</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(proxy.hashCode());//报错</span></span><br><span class="line">        <span class="keyword">if</span> (proxy <span class="keyword">instanceof</span> Proxy)</span><br><span class="line">            System.out.println(<span class="string">"yes proxy"</span>);</span><br><span class="line">        System.out.println(<span class="string">"start..."</span>);</span><br><span class="line">        method.invoke(userService,args);</span><br><span class="line">        System.out.println(<span class="string">"end...."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserProxy userProxy = <span class="keyword">new</span> UserProxy();</span><br><span class="line">      	<span class="comment">//获取代理对象</span></span><br><span class="line">        Object proxy = userProxy.bind(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        Proxy proxy1 = (Proxy) proxy;</span><br><span class="line">        <span class="comment">//System.out.println(proxy1.hashCode());//报错</span></span><br><span class="line">      	<span class="comment">//强转为被代理类型</span></span><br><span class="line">        UserService userService = (UserService) proxy;</span><br><span class="line">        <span class="comment">//为什么$Proxy0.hashCode(Unknown Source)</span></span><br><span class="line">        <span class="comment">//System.out.println(userService.hashCode());//报错</span></span><br><span class="line">        userService.add();</span><br><span class="line">        userService.del();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="五、输出"><a href="#五、输出" class="headerlink" title="五、输出"></a>五、输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start...</span><br><span class="line">aaaadd</span><br><span class="line">end....</span><br><span class="line">start...</span><br><span class="line">dddddel</span><br><span class="line">end....</span><br></pre></td></tr></table></figure>
<h3 id="invoke第一个参数proxy"><a href="#invoke第一个参数proxy" class="headerlink" title="invoke第一个参数proxy"></a>invoke第一个参数proxy</h3><p><code>public Object invoke(Object proxy, Method method, Object[] args)</code> 中的proxy是该代理对象，是$Proxy0类</p>
<p>如果在invoke中调用proxy.toString()，则会产生死循环，不断调用自己的invoke方法。</p>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-6/72956100.jpg" alt=""></p>
<p><strong>因为调用Proxy的toString()方法，会去使用invoke方法来执行toString()方法。在invoke中又要执行Proxy的toString()方法…..无限循环。</strong></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>调用代理对象proxy.hashCode()（userService.hashCode()）方法为什么报错？</p>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-6/55200975.jpg" alt=""></p>
<p>而且在Client.main中注释掉对<code>add</code>和<code>del</code>的调用，报错同样打印<code>start..</code>和<code>end..</code>。如下所示    、</p>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-6/22858027.jpg" alt="">                        </p>
<p>​</p>
</li>
<li><p>同上使用IDEA  debug时会莫名执行invoke()中的方法？而直接run则没问题。</p>
</li>
</ul>
<p>### </p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="http://paddy-w.iteye.com/blog/841798" target="_blank" rel="external">InvocationHandler中invoke()方法的调用问题</a></li>
<li><a href="http://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="external">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM的类加载机制]]></title>
      <url>http://4rnold.github.io/2016/07/04/JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="类的加载、链接和初始化"><a href="#类的加载、链接和初始化" class="headerlink" title="类的加载、链接和初始化"></a>类的加载、链接和初始化</h1><ul>
<li><p>加载：查找并加载二进制数据</p>
<blockquote>
<p>.class文件中的二进制数据读入到内存。放在<code>运行时数据区的方法区</code> 内，然后再<code>堆</code> 区创建一个java.lang.Class对象，封装类的数据结构，通过各个类在堆区的class对象就能实现对类的操作（反射什么的）。</p>
</blockquote>
</li>
</ul>
<ul>
<li>连接<ul>
<li>验证：类的正确性（确实是个java的类不是C++ 的）</li>
<li>准备：为<code>静态变量</code>分配空间并初始化<code>默认值</code>（<strong>还没有赋值，先赋为默认值</strong>），如果是static final 则在准备阶段就会被赋值。</li>
<li>解析：把类中<code>符号引用</code>转为<code>直接引用</code> （指针指向真正要执行方法的内存地址）</li>
</ul>
</li>
<li>初始化：静态变量赋<code>初始值</code> （前面是默认值）。staic{} 执行。</li>
</ul>
<a id="more"></a>
<p>在六种对类的第一次<code>主动使用</code>时才会去初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Test&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">6</span>/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//访问Test.x不运行，</span></span><br><span class="line">    <span class="comment">//如果x = new Random().nextInt(10)则运行此方法。</span></span><br><span class="line">    <span class="comment">//如果x不是final 则运行此方法。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassLoader.loadClass() 加载类不是对类的主动使用（仅仅加载不会调用初始化方法）</p>
<blockquote>
<p>TIPS : 加载匿名内部类可以使用诸如<code>“java.net.URLClassLoader$3$1”</code>表明URLClassLoader中第3个匿名内部类中的第一个匿名内部类</p>
</blockquote>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li><p>java自带加载器</p>
<ul>
<li><p>根加载器（Bootstrap）所加载类的.getClassLoader()得到null</p>
<p>根加载器实现依赖底层操作系统。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>扩展类加载器（Extension）</p>
<p>​    从java.ext.dirs系统属性指定目录加载类库，或从JDK安装魔力jre/lib/ext目录加载</p>
</li>
<li><p>系统类加载器（System）</p>
<p>  从环境变量classpath或java.class.path指定的目录中加载</p>
</li>
<li><p>用户自定义加载器（classloader的子类）</p>
</li>
</ul>
<p><img src="http://o8n1hrt12.bkt.clouddn.com/2016-07-23-14-43-37.png" alt=""> </p>
<p>加载类的加载器是<code>定义类加载器</code>，其子类加载器是<code>初始类加载器</code></p>
<p><strong>父加载器加载的类不能看见子加载器加载的类。</strong></p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = loadder1.loadClass(<span class="string">"Sample.class"</span>);</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        Sample sample = (Sample)object;<span class="comment">//报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中Client由System加载，Sample类由自定义类加载器（Loader1）加载，所以main中无法访问sample。可以使用<code>反射</code>方法来突破这种限制。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class clazz = loadder1.loadClass(<span class="string">"Sample.class"</span>);</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        Field field = clazz.getField(<span class="string">"v1"</span>);<span class="comment">//反射</span></span><br><span class="line">        <span class="keyword">int</span> v1 = field.getInt(object);</span><br><span class="line">        System.out.println(<span class="string">"v1:"</span> + v1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h2><p>当<code>自定义类加载器</code>加载的类的生命周期结束时，该类<code>方法区</code> 内的数据也会被<code>卸载</code>。</p>
<p>而<code>系统类加载器</code>(三种) 加载的类始终不会被卸载。</p>
<h2 id="引用变量与对象的引用关系"><a href="#引用变量与对象的引用关系" class="headerlink" title="引用变量与对象的引用关系"></a>引用变量与对象的引用关系</h2><p><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-4/24473210.jpg" alt=""></p>
<p>(图引自：<a href="http://www.cnblogs.com/mengdd/p/3594608.html" target="_blank" rel="external">http://www.cnblogs.com/mengdd/p/3594608.html</a>)</p>
<p>卸载：Class对象被卸载，方法区类二进制数据被卸载（可以通过Class.hashCode()来判断）。（是否说明方法区内和Class对象是始终一一对应的？）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客文件名带&符号导致localsearch失效问题]]></title>
      <url>http://4rnold.github.io/2016/07/01/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%90%8D%E5%B8%A6%E7%AC%A6%E5%8F%B7%E5%AF%BC%E8%87%B4localsearch%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>之前有一篇名为“JavaWeb开发(1)——Servlet&amp;JSP”的文章，在hexo中对应的文件名为“JavaWeb开发(1)——Servlet&amp;JSP.md”,随后发现hexo localsearch 不能使用。查看配置无问题。</p>
<p>访问<a href="http://localhost:4000/search.xml" target="_blank" rel="external">http://localhost:4000/search.xml</a> 报如下错误<br><img src="http://o8n1hrt12.bkt.clouddn.com/16-7-1/16203251.jpg" alt=""></p>
<p>逐个排查后发现md文件名不能带 <code>&amp;</code> 符号。</p>
<p>以后md文件还是避免使用符号为好。</p>
<p>另外，将文件名中&amp;转义为<code>&amp;amp;</code>后搜索功能可用。但是文章链接无法打开。因为hexo将md文件名作为当前文章的url，<code>&amp;amp;</code>转义后为&amp;，&amp;是url关键字。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[装饰器模式 和 代理模式 区别]]></title>
      <url>http://4rnold.github.io/2016/07/01/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%20%E5%92%8C%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%20%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<ul>
<li>装饰器是对现有对象的一种装饰</li>
<li>代理模式是直接生成一个代理对象。</li>
</ul>
<ul>
<li>装饰器是通过set方法传入对象，</li>
<li>代理模式是直接在初始化时new 一个对象。</li>
</ul>
<ul>
<li>装饰者建立后，修饰完a 还可以修饰b对象。</li>
<li>代理模式是创建后对象就确定了。就是建立一个代理A类的对象。</li>
</ul>
<p>貌似挺无聊的..都是包装了一层。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb开发(2)——cookie&session&EL&filter]]></title>
      <url>http://4rnold.github.io/2016/07/01/JavaWeb%E5%BC%80%E5%8F%91(2)%E2%80%94%E2%80%94cookie%20and%20session%20and%20EL%20and%20filter/</url>
      <content type="html"><![CDATA[<p><em>私人笔记仅作个人记录用</em></p>
<hr>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>当服务端传cookie到客户端（http头中的Set-Cookie字段），那么客户端后面的请求将携带cookie信息。<br>所以….==之前看到的静态文件推荐使用独立域名，可以避免访问静态文件也携带cookie，浪费网络带宽。==</p>
<h2 id="Cookie的作用范围"><a href="#Cookie的作用范围" class="headerlink" title="Cookie的作用范围"></a>Cookie的作用范围</h2><p>cookie.setPath(request.getContextPath());</p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>只有调用 request.getSession() 或 request.getSession(true) 才创建session对象。</p>
<h2 id="session-的生命周期"><a href="#session-的生命周期" class="headerlink" title="session 的生命周期"></a>session 的生命周期</h2><p>在 tomcat中的web.xml可以设置 session最大时间</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="session-url-重写"><a href="#session-url-重写" class="headerlink" title="session url 重写"></a>session url 重写</h2><p>respose.encodeURL(“hello.jsp”) 会对将JSESSIONID附在url后面。</p>
<hr>
<h1 id="jsp-amp-servlet-路径问题"><a href="#jsp-amp-servlet-路径问题" class="headerlink" title="jsp&amp;servlet 路径问题"></a>jsp&amp;servlet 路径问题</h1><p>相对路径 servlet目录 和jsp 不一样，导致页面404，所以推荐使用绝对路径。</p>
<p>绝对路径涉及到 “/” 的使用：</p>
<p><strong>代表web应用路径的情况： (交给servlet容器处理)</strong></p>
<ul>
<li>请求转发： request.getRequestDispatcher(“/path/b.jsp”).forward(req,res);</li>
<li>web.xml 中映射Servlet 访问路径<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/abc<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代表站点根路径的情况： (交给浏览器处理)</strong></p>
<ul>
<li>超链接 <a herf="/webapp/a.jsp"></a></li>
</ul>
<p>通常使用request.getContextPath() 组合为绝对路径。</p>
<h1 id="EL-表达式"><a href="#EL-表达式" class="headerlink" title="EL 表达式"></a>EL 表达式</h1><ul>
<li><p>隐藏对象 </p>
<ul>
<li>pageScope</li>
<li>requestScope</li>
<li>sessionScope</li>
<li>applicationScope</li>
</ul>
</li>
<li><p>请求参数</p>
<ul>
<li>param</li>
<li>paramValues</li>
</ul>
</li>
<li><p>其他隐含对象</p>
<ul>
<li>cookie</li>
<li>header 请求头</li>
<li>headerValues</li>
<li>initParam</li>
<li>pageContext</li>
</ul>
</li>
</ul>
<p>==pageContext.session 和 sessionScope 区别??==</p>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>过滤器中<code>&lt;dispathcer&gt;</code>节点指定过滤器所拦截的资源被<code>servlet容器</code>的调用方式。可以指定多个。</p>
<p>可以是REQUEST,INCLUDE,FORWARD,ERROR之一，默认REQUEST。</p>
<hr>
<blockquote>
<p>TIPS: 各种URL<br><img src="http://o8n1hrt12.bkt.clouddn.com/16-6-30/93659693.jpg" alt=""><br>request.getContextPath() 得到当前应用的路径</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb开发(1)——Servlet&JSP]]></title>
      <url>http://4rnold.github.io/2016/06/30/JavaWeb%E5%BC%80%E5%8F%91(1)%E2%80%94%E2%80%94Servlet%20and%20JSP/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>问题：针对新建的web工程，需要手动将编译好的类复制到<code>WEB-INF/classes</code>目录下。麻烦</strong></p>
<blockquote>
<p>Eclipse中Java Build Path &gt; Source 设置Default output folder 到 WEB-INFO/classes目录</p>
</blockquote>
<p><strong>问题：tomcat webapp目录如何映射到工程目录？</strong></p>
<blockquote>
<p>配置Tomcat <context>元素，不要直接在server.xml中配置<context>元素，<br>    因为tomcat启动后将不再读取server.xml，因此无法在Tomcat启动的状态下 发布web应用。</context></context></p>
<p>通过创建独立的xml文件的方式来配置<context>，Tomcat 以Xml文件名作为Web应用的上下文路径。<br>    忽略<context>中 path 属性。</context></context></p>
<p>在apache/conf/ 目录下建立catalina/localhost目录，该目录下建立<code>helloworld.xml</code>文件。其中helloworld为访问路径<a href="http://localhost:8080/`helloworld`/xxxx" target="_blank" rel="external">http://localhost:8080/`helloworld`/xxxx</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/test2"</span> <span class="attr">docBase</span>=<span class="string">""</span> <span class="attr">reloadable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中path 为浏览器访问目录(无用)，docBase为WebApp所在目录（WebContent目录）。</p>
</blockquote>
<a id="more"></a>
<h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="servlet-配置"><a href="#servlet-配置" class="headerlink" title="servlet 配置"></a>servlet 配置</h2><p><strong>注意：</strong><servlet-mapping> 中的 <url-pattern> 如果带<em>的话只能是 `/</em><code>或 *加扩展名</code><em>.xxx` 其他带 </em>的均不合法</url-pattern></servlet-mapping></p>
<h2 id="servlet-生命周期"><a href="#servlet-生命周期" class="headerlink" title="servlet 生命周期"></a>servlet 生命周期</h2><blockquote>
<p>构造方法 -&gt; init方法 -&gt; service方法 -&gt; destory方法</p>
</blockquote>
<h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><p>init 方法参数</p>
<p>在<servlet>节点中配置<init-param>,可配置多组<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></init-param></servlet></p>
<p>通过servletConfig中的方法可以获取到其中的值。</p>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>可通过ServletConfig.getServletContext 获取</p>
<p>该对象代表当前web应用，可以取到该应用的各方面信息</p>
<h3 id="1-获取web-xml中web应用配置参数"><a href="#1-获取web-xml中web应用配置参数" class="headerlink" title="1.获取web.xml中web应用配置参数"></a>1.获取web.xml中web应用配置参数<context-param></context-param></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>相对于<init-param>，<context-param>可看作的全局参数。</context-param></init-param></p>
<h3 id="2-getRealPath-String-path"><a href="#2-getRealPath-String-path" class="headerlink" title="2.getRealPath(String path)"></a>2.getRealPath(String path)</h3><p>获取发布在服务器上的绝对路径</p>
<p>可用于查找eclipse在本地真正发布项目的位置</p>
<h3 id="3-getContextPath"><a href="#3-getContextPath" class="headerlink" title="3.getContextPath()"></a>3.getContextPath()</h3><p>获取当前web 应用名称</p>
<h3 id="4-getResourceAsStream-String-path"><a href="#4-getResourceAsStream-String-path" class="headerlink" title="4.getResourceAsStream(String path)"></a>4.getResourceAsStream(String path)</h3><p>获取某一文件对应的输入流</p>
<h2 id="ServletRequest-amp-ServletResponse"><a href="#ServletRequest-amp-ServletResponse" class="headerlink" title="ServletRequest &amp; ServletResponse"></a>ServletRequest &amp; ServletResponse</h2><p>service方法参数</p>
<p>这是两个接口，不同的servlet容器具体实现，传入service方法。</p>
<p><code>HttpServletRequest</code> 是 <code>ServletRequest</code> 子接口，封装http相关信息</p>
<h2 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h2><p>实现了<code>Servlet</code>接口。为了让子类不重写所有的servlet中的方法。</p>
<p>同时实现了<code>ServletConfig</code>接口，所以可以在service方法中直接方便使用 ServletConfig 对象的方法。 </p>
<blockquote>
<p>TIPS :IDEA 不能自动下载servlet-api源码（建立的Web Application 工程），显示从maven上没有搜索到。需要手工从<a href="http://tomcat.apache.org/index.html" target="_blank" rel="external">http://tomcat.apache.org/index.html</a> 下载源码后加载。</p>
</blockquote>
<h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><p>HttpServlet 继承 GenericServlet，重载service方法，将ServletRequest 和 ServletResponse 转为 HttpServletRequest 和 HttpServletResponse。<br>并根据请求分出 doGet和 doPost方法。</p>
<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="JSP-隐含对象"><a href="#JSP-隐含对象" class="headerlink" title="JSP 隐含对象"></a>JSP 隐含对象</h2><ul>
<li>request：HttpServletRequest</li>
<li><del>response</del>：HttpServletResponse（在jsp页面基本不用）</li>
<li>pageContext：页面上下文</li>
<li>session: HttpSession</li>
<li>application: servletContext，当前web应用。</li>
<li><del>config</del>：对应servlet中的servletConfig 可以获取配置参数，那么问题来了..</li>
</ul>
<p><strong>问题： jsp页面的参数则呢配置？</strong></p>
<blockquote>
<p>同普通servlet一样，只需要将原来<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.arnold.Test.MyFirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">&gt; 替换为</span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">jsp-file</span>&gt;</span>/hello.jsp<span class="tag">&lt;/<span class="name">jsp-file</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>因为jsp本质也是一个servlet类么..但这样就只能通过访问servletName来访问此jsp</p>
</blockquote>
<ul>
<li>out: JspWriter, 调用out.println()可以直接打印</li>
<li><del>page</del>: 为object对象 基本不用。</li>
<li>exception: jsp页面声明&lt;%@ page isErrorPage=”true” %&gt;才可用</li>
</ul>
<h2 id="JSP-内置对象作用范围"><a href="#JSP-内置对象作用范围" class="headerlink" title="JSP 内置对象作用范围"></a>JSP 内置对象作用范围</h2><ul>
<li>pageContext : 当前jsp页面</li>
<li>request： 同一个请求</li>
<li>session： 同一个回话</li>
<li>application： 同一个应用</li>
</ul>
<h2 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h2><ul>
<li>session： 当前页面是否允许使用session</li>
<li>ErrorPage：指定错误页面指向，然后错误页面要使用isErrorPage=true,使用exception对象</li>
</ul>
<blockquote>
<p>TIPS: errorPage.jsp 一般不能直接方法，所以放到WEB-INF中，通过forward转发可以访问。</p>
<p>TIPS: 通常在web.xml中配置错误页面信息<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span><span class="comment">&lt;!--可根据错误代码或异常类型判断--&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">location</span>&gt;</span>/WEB-INFO/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>contentType：实际调用的response.setContentType</li>
<li>pageEncoding: 当前jsp页面的字符编码，通常和contentType的charset一致</li>
</ul>
<blockquote>
<p>TIPS: <a href="http://my.oschina.net/chape/blog/138828" target="_blank" rel="external">contentType和pageEncoding的区别</a></p>
</blockquote>
<h2 id="include指令静态引入"><a href="#include指令静态引入" class="headerlink" title="include指令静态引入"></a>include指令静态引入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=&quot;url&quot;%&gt;</span><br></pre></td></tr></table></figure>
<p>静态包含，最后只生成<code>一个class</code>。</p>
<h2 id="动态引入"><a href="#动态引入" class="headerlink" title="动态引入"></a><jsp:include>动态引入</jsp:include></h2><p>生成两个class</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><jsp:forward></jsp:forward></h2><p>相当于request.getRequestDispathcer(“b.jsp”).forward(request,response);</p>
<h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forward 一次请求</span></span><br><span class="line">String path = <span class="string">"testPath"</span>;</span><br><span class="line">RequestDispatcher requestDispatcher = request.getRequestDispatcher(<span class="string">"/"</span> + path);</span><br><span class="line">requestDispatcher.forward(request,response);</span><br><span class="line"></span><br><span class="line"><span class="comment">//redirect 两次请求(网址会变)</span></span><br><span class="line">response.sendRedirect(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>forward是发送给web容器，然后web容器转发</strong>，Request对象不变。</li>
<li>redirect是浏览器302转发。</li>
</ul>
<p>forward “/” 代表当前web应用的根目录<br>redirect “/” 代表当前web站点的根目录</p>
]]></content>
    </entry>
    
  
  
</search>
